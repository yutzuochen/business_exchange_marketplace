package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"strconv"
	"trade_company/graph/model"
	"trade_company/internal/auth"
	gqlctx "trade_company/internal/graphql"
	"trade_company/internal/models"

	"golang.org/x/crypto/bcrypt"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}
	user := models.User{Email: email, PasswordHash: string(hash)}
	if err := r.DB.Create(&user).Error; err != nil {
		return nil, err
	}
	token, err := auth.GenerateToken(r.Cfg, user.ID, user.Email)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{Token: token}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user models.User
	if err := r.DB.Where("email = ?", email).First(&user).Error; err != nil {
		return nil, err
	}
	if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil {
		return nil, err
	}
	token, err := auth.GenerateToken(r.Cfg, user.ID, user.Email)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{Token: token}, nil
}

// CreateListing is the resolver for the createListing field.
func (r *mutationResolver) CreateListing(ctx context.Context, input model.CreateListingInput) (*model.Listing, error) {
	userID, ok := gqlctx.UserIDFromContext(ctx)
	if !ok {
		return nil, ErrUnauthorized
	}
	ls := models.Listing{
		Title:       input.Title,
		Description: coalesceStrPtr(input.Description),
		Price:       int64(input.Price),
		Location:    coalesceStrPtr(input.Location),
		OwnerID:     userID,
	}
	if err := r.DB.Create(&ls).Error; err != nil {
		return nil, err
	}
	desc := ls.Description
	loc := ls.Location
	return &model.Listing{
		ID:          strconv.FormatUint(uint64(ls.ID), 10),
		Title:       ls.Title,
		Description: &desc,
		Price:       int(ls.Price),
		Location:    &loc,
		OwnerID:     strconv.FormatUint(uint64(ls.OwnerID), 10),
		CreatedAt:   timePtrToStringPtr(&ls.CreatedAt),
		UpdatedAt:   timePtrToStringPtr(&ls.UpdatedAt),
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := gqlctx.UserIDFromContext(ctx)
	if !ok {
		return nil, nil
	}
	var u models.User
	if err := r.DB.First(&u, userID).Error; err != nil {
		return nil, nil
	}
	return &model.User{ID: strconv.FormatUint(uint64(u.ID), 10), Email: u.Email, CreatedAt: timePtrToStringPtr(&u.CreatedAt), UpdatedAt: timePtrToStringPtr(&u.UpdatedAt)}, nil
}

// Listings is the resolver for the listings field.
func (r *queryResolver) Listings(ctx context.Context, limit *int) ([]*model.Listing, error) {
	l := 50
	if limit != nil {
		l = *limit
	}
	var listings []models.Listing
	if err := r.DB.Order("id desc").Limit(l).Find(&listings).Error; err != nil {
		return nil, err
	}
	result := make([]*model.Listing, 0, len(listings))
	for _, ls := range listings {
		lsCopy := ls
		result = append(result, &model.Listing{
			ID:          strconv.FormatUint(uint64(lsCopy.ID), 10),
			Title:       lsCopy.Title,
			Description: &lsCopy.Description,
			Price:       int(lsCopy.Price),
			Location:    &lsCopy.Location,
			OwnerID:     strconv.FormatUint(uint64(lsCopy.OwnerID), 10),
			CreatedAt:   timePtrToStringPtr(&lsCopy.CreatedAt),
			UpdatedAt:   timePtrToStringPtr(&lsCopy.UpdatedAt),
		})
	}
	return result, nil
}

// Listing is the resolver for the listing field.
func (r *queryResolver) Listing(ctx context.Context, id string) (*model.Listing, error) {
	idUint, _ := strconv.ParseUint(id, 10, 64)
	var ls models.Listing
	if err := r.DB.First(&ls, idUint).Error; err != nil {
		return nil, nil
	}
	desc := ls.Description
	loc := ls.Location
	return &model.Listing{
		ID:          strconv.FormatUint(uint64(ls.ID), 10),
		Title:       ls.Title,
		Description: &desc,
		Price:       int(ls.Price),
		Location:    &loc,
		OwnerID:     strconv.FormatUint(uint64(ls.OwnerID), 10),
		CreatedAt:   timePtrToStringPtr(&ls.CreatedAt),
		UpdatedAt:   timePtrToStringPtr(&ls.UpdatedAt),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
